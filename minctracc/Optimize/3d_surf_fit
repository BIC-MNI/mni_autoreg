
    
    gradient_magnitude = norm[X]*norm[X] + 
                         norm[Y]*norm[Y] + 
			 norm[Z]*norm[Z];

    if ( !flag &&  (gradient_magnitude < eps*eps)) {
				/* ret_prin_dir failed because of
				   small gradient mag, so I'll return
				   the mean neighbourhood position */
      for_inclusive(i,X,Z)
	smoothed_result[i] = neighbour_mean[i];
    } else {

      gradient_magnitude = sqrt(gradient_magnitude);

      tmp = ABS(k1);
      q_sum_k1 += tmp;
      q_sum2_k1 += tmp*tmp;
      if (tmp>q_max_k1) q_max_k1 = tmp; else if (tmp<q_min_k1) q_min_k1 = tmp;

      tmp = ABS(k2);
      q_sum_k2 += tmp;
      q_sum2_k2 += tmp*tmp;
      if (tmp>q_max_k2) q_max_k2 = tmp; else if (tmp<q_min_k2) q_min_k2 = tmp;

      q_sum_n += gradient_magnitude;
      q_sum2_n += gradient_magnitude*gradient_magnitude;
      if (gradient_magnitude>q_max_n) 
	q_max_n = gradient_magnitude; 
      else if (gradient_magnitude<q_min_n) 
	q_min_n = gradient_magnitude;

      q_count++;
      
      for_inclusive(i,X,Z)
	norm[i] = norm[i] / gradient_magnitude;
      
      if (!flag) {		
	
	/* ret_prin_dir failed to find perpendicular directions -> we
	   must be on an extremal point on the iso surf, so

	   build two direction vectors perpendicular to norm, and set
	   curvatures equal*/

	build_two_perpendicular_vectors(norm, e1, e2);
	k1 = k2 = (k1+k2)/2.0;
      }

      c_max = ABS(k1) / (A_const + B_const*Smin  +C_const*ABS(k1));
      c_min = ABS(k2) / (A_const + B_const*Smin  +C_const*ABS(k2));
      c_norm= gradient_magnitude / G_MEAN;

      for_inclusive(i,X,Z) {
	diff[i] = previous_def[i] + additional_def[i] - neighbour_mean[i];
      }
      len1 = diff[0]*e1[X] + diff[Y]*e1[Y] + diff[Z]*e1[Z];
      len2 = diff[0]*e2[X] + diff[Y]*e2[Y] + diff[Z]*e2[Z];
      len3 = diff[0]*norm[X] + diff[Y]*norm[Y] + diff[Z]*norm[Z];
				/* see eq. above for def(n+1) */
      for_inclusive(i,X,Z) {
	smoothed_result[i] = neighbour_mean[i] + 
	                     (c_max/(c_max+1.0))  * len1 * e1[i] +
			     (c_min/(c_min+1.0))  * len2 * e2[i] +
			     (c_norm/(c_norm+1.0))* len3 * norm[i];
      }

    }

    